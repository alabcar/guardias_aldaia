<!-- /index.html -->
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Guardias Aldaia — Frecuencias (Oct 2025 → Jun 2026)</title>
<style>
  :root{--bg:#f6f8fa;--card:#fff;--muted:#666}
  body{background:var(--bg);font-family:Inter,Segoe UI,Arial,sans-serif;color:#111;margin:0}
  .wrap{max-width:1200px;margin:20px auto;padding:18px}
  header{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;gap:12px;margin-bottom:14px}
  h1{margin:0;font-size:1.1rem}
  .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.06);margin-bottom:16px}
  .flex{display:flex;gap:12px;flex-wrap:wrap}
  .doctors{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:8px}
  .pill{display:flex;align-items:center;gap:8px;background:#fafafa;border:1px solid #eee;border-radius:10px;padding:6px 8px}
  .sw{width:18px;height:12px;border-radius:4px;display:inline-block}
  .muted{color:var(--muted)}
  .actions{display:flex;gap:8px;align-items:center}
  button{background:#0b74de;color:#fff;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
  .months{
    display:block;
    width:90%;
    max-width:680px;
    margin:0 auto;
    transition:width 0.2s;
  }
  @media (max-width: 900px) {
    .months { width:98%; max-width:100vw; padding:0 2vw; }
    .month { padding:8px; }
    .grid { gap:4px; padding:4px; }
    .cell { min-height:44px; font-size:0.78rem; padding:5px; }
    .month h3 { font-size:1rem; }
  }
  @media (max-width: 520px) {
    .months { width:100%; max-width:100vw; padding:0 1vw; }
    .month { padding:4px; }
    .grid { gap:2px; padding:2px; }
    .cell { min-height:32px; font-size:0.72rem; padding:3px; }
    .month h3 { font-size:0.92rem; }
  }
  @media (max-width: 420px) {
    .months { width:100%; max-width:100vw; padding:0 0.5vw; }
    .month { padding:2px; }
    .grid { gap:1px; padding:1px; }
    .cell { min-height:24px; font-size:0.62rem; padding:2px; }
    .month h3 { font-size:0.82rem; }
    .tag { font-size:0.78rem; padding:2px 4px; }
    .date { font-size:0.7rem; }
  }
  .month{width:100%;background:#fff;border-radius:10px;padding:18px;box-shadow:0 6px 18px rgba(0,0,0,0.04);min-width:0;}
  @media(max-width:900px){ .months{grid-template-columns:1fr;} .month{padding:8px;} }
  .month h3{margin:4px 0 12px;text-align:center;font-size:1.1rem}
  .grid{display:grid;grid-template-columns:repeat(7,1fr);gap:10px;background:#ddd;padding:10px;border-radius:12px;width:100%;min-width:0;}
  .cell{background:#fff;min-height:60px;font-size:0.85rem;padding:8px;display:flex;flex-direction:column;align-items:flex-start;border-radius:8px;transition:border 0.2s;}
  .cell.empty{background:transparent;min-height:36px;border:none}
  /* Borde rojo para festivos */
  .cell.festivo{background:#ffecec !important;border:4px solid #e74c3c !important;border-radius:12px !important;box-shadow:0 0 0 2px #e74c3c44;}
  .cell.festivo .date{color:#b00;font-weight:700;}
  .date{font-weight:700;margin-bottom:6px}
  .tag{display:inline-block;padding:3px 6px;border-radius:8px;margin:3px 0;font-size:0.92rem;font-weight:500}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid #eee;padding:6px;text-align:center;font-size:0.82rem}
  th{background:#fafafa}
  /* tipos de día */
  .festivo{background:#ffecec}
  .puente{background:#fff2dc}
  .pref{background:#e6f4ff}
  .sabado{background:#fff8f0}
  .domingo{background:#f0f0f0}
  /* Resumen mensual compacto */
  .month-summary{margin-top:10px}
  .month-summary h4{margin:8px 0 6px;font-size:0.95rem;text-align:left}
  .month-summary table{font-size:0.78rem}
  .month-summary td:first-child{text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Guardias Aldaia — Frecuencias por grupo</h1>
    <div class="actions">
      <button id="btnGenerar">Generar automáticamente</button>
    </div>
  </header>

  <!-- Leyenda y médicos -->
  <div class="card">
    <h3 style="margin:0 0 8px">Médicos y guardias/mes</h3>
    <div class="doctors" id="doctorsList"></div>
    <div style="height:10px"></div>
    <div class="muted">
      <strong>Reglas de asignación:</strong><br>
      1) Emparejamientos preferidos: <em>Rigo–Luceth</em>, <em>Adela–Mica</em> (si ambos cumplen su intervalo y no hay días consecutivos).<br>
      2) Equilibrar <em>sábados</em>, <em>festivos</em>, <em>prefestivos</em> y <em>puentes</em> (se prioriza quien menos tenga en el periodo, equilibrando proporcionalmente al número de guadias).<br>
      3) Respetar intervalo mínimo entre guardias: <br>
         &nbsp;&nbsp;• 8 guardias/mes → cada 4 días<br>
         &nbsp;&nbsp;• 4 guardias/mes → cada 8 días<br>
         &nbsp;&nbsp;• 3 guardias/mes → cada 10 días<br>
         &nbsp;&nbsp;• 2 guardias/mes → cada 15 días<br>

      4) Nunca dos días seguidos para la misma persona.<br>
      5) Puedes modificar el número de guardias/mes de cada médico y volver a generar el calendario.<br>
      6) Los festivos se marcan con borde rojo.<br>
    </div>
  </div>

  <!-- Resumen antes del calendario -->
  <div class="card">
    <h3 style="margin:0 0 8px">Resumen del periodo</h3>
    <table>
      <thead>
        <tr>
          <th>Médico</th><th>Total</th><th>Sab</th><th>Dom</th><th>Fest</th><th>Prefest</th><th>Puente</th>
        </tr>
      </thead>
      <tbody id="resumenBody"></tbody>
    </table>
      <div id="pairSummary"></div>
  </div>

  <!-- Calendarios -->
  <div class="card">
    <h3 style="margin:0 0 8px">Calendario (Oct 2025 → Jun 2026)</h3>
    <div id="months" class="months"></div>
  </div>
</div>

<script>
/* =====================
   Datos base (precarga)
   ===================== */
const MEDICOS = [
  { nombre: "Adela",  mes: 8 },
  { nombre: "Rigo",   mes: 8 },
  { nombre: "Merino", mes: 4 },
  { nombre: "Mica",   mes: 4 },
  { nombre: "Naby",   mes: 2 },
  { nombre: "Estrella", mes: 4 },
  { nombre: "Amparo", mes: 2 },
  { nombre: "Sara",   mes: 4 },
  { nombre: "Luceth", mes: 4 },
  { nombre: "Salva",  mes: 2 },
  { nombre: "Brian",  mes: 4 },
  { nombre: "Marta",  mes: 2 },
  { nombre: "Julia",  mes: 2 },
  { nombre: "Pepe",   mes: 2 },
  { nombre: "Wendy",  mes: 2 },
  { nombre: "Lerma",  mes: 2 },
  { nombre: "Silvia", mes: 2 }
];
const PASTEL = ["#FFB3BA","#FFDFBA","#FFFFBA","#BAFFC9","#BAE1FF","#D7BAFF","#FFC8DD","#BFD8B8","#FFDAC1","#E2F0CB","#FF9CEE","#F0C9FF","#B5EAD7","#C7CEEA","#FFCCF9","#C2F0FC"];
const color = {}; MEDICOS.forEach((m,i)=> color[m.nombre]=PASTEL[i%PASTEL.length]);

// Festivos (CV y nacionales dentro del periodo Oct-2025 → Jun-2026)
const FESTIVOS = new Set([
  '2025-10-09','2025-11-01','2025-12-06','2025-12-08','2025-12-25',
  '2026-01-01','2026-01-06','2026-03-19','2026-03-29','2026-04-02','2026-04-03','2026-04-06','2026-05-01'
]);

/* =====================
   Utilidades de fechas
   ===================== */
function pad(n){return n<10?'0'+n:''+n}
function iso(y,m,d){return `${y}-${pad(m)}-${pad(d)}`}
function ymd(dt){return iso(dt.getFullYear(),dt.getMonth()+1,dt.getDate())}
function addDays(d,n){const D=new Date(d);D.setDate(D.getDate()+n);return D}
function esSab(dt){return dt.getDay()===6}
function esDom(dt){return dt.getDay()===0}
function esFest(dt){return FESTIVOS.has(ymd(dt))}
function esPref(dt){return FESTIVOS.has(ymd(addDays(dt,1)))}
function esPuente(dt){return FESTIVOS.has(ymd(addDays(dt,-1)))||FESTIVOS.has(ymd(addDays(dt,1)))}

/* ===========================
   Construir meses (L → D)
   =========================== */
const months = []; // [{year,month,days:[{empty?, date, iso, flags}]}]
function buildMonths(){
  months.length=0;
  let y=2025,m=9; // Oct (0-based)
  while(y<2026 || (y===2026 && m<=5)){
    const first=new Date(y,m,1), lastDay=new Date(y,m+1,0).getDate();
    const days=[], offset=(first.getDay()+6)%7;
    for(let i=0;i<offset;i++) days.push({empty:true});
    for(let d=1; d<=lastDay; d++){
      const dt=new Date(y,m,d);
      days.push({
        empty:false,
        date:dt,
        iso: ymd(dt),
        sab: esSab(dt),
        dom: esDom(dt),
        fest: esFest(dt),
        pref: esPref(dt),
        puente: esPuente(dt)
      });
    }
    while(days.length%7!==0) days.push({empty:true});
    months.push({year:y, month:m, days});
    m++; if(m>11){m=0;y++}
  }
}

/* ====================================
   Lógica de frecuencias y asignación
   ==================================== */
function intervaloPorMes(guardiasMes){
  if(guardiasMes>=8) return 4;
  if(guardiasMes===4) return 8;
  if(guardiasMes===3) return 10;
  if(guardiasMes===2) return 15;
  if(guardiasMes<=1) return 30;
  return Math.max(3, Math.round(30/guardiasMes));
}

/* ====================================
   Config emparejamientos y límites globales
   ==================================== */
const canonicalPair = (a,b)=> a<b ? `${a}|${b}` : `${b}|${a}`;
// Parejas preferidas (global)
const PREFERRED = new Set([canonicalPair('Rigo','Luceth'), canonicalPair('Adela','Mica')]);

// Nueva preferencia: favorecer Julia–Marta y al grupo (Julia, Marta, Amparo, Silvia, Pepe)
const PRIORITY_GROUP = new Set(['Julia','Marta','Amparo','Silvia','Pepe']);
// Objetivo total para el periodo (Oct 2025 → Jun 2026)
// Límites por periodo (más permisivo dentro del grupo priorizado)
const PAIR_LIMITS = { perPeriod: 3, groupPerPeriod: 6, preferredPerPeriod: Number.POSITIVE_INFINITY };
function pairLimitForKey(k){
  const [a,b] = k.split('|');
  if (PREFERRED.has(k)) return PAIR_LIMITS.preferredPerPeriod;
  if (PRIORITY_GROUP.has(a) && PRIORITY_GROUP.has(b)) return PAIR_LIMITS.groupPerPeriod;
  return PAIR_LIMITS.perPeriod;
}

function generarAsignacion(){
  const asig = {}; // iso -> [nombres...]
  const last = {};     // última fecha asignada
  const monthCount = {}; // isoMonth 'YYYY-MM' -> { medico:count }
  const tipoCount = {};  // equilibrio por tipos
  MEDICOS.forEach(m=>{
    last[m.nombre]=null;
    tipoCount[m.nombre]={sab:0,fest:0,pref:0,puente:0,dom:0};
  });
  

  // ---- Diversidad de parejas ----
  const pairCount = {}; // 'A|B' -> total en el periodo
  const pairCountMonth = {}; // 'YYYY-MM' -> { 'A|B': count }
  const lastPair = {}; // 'A|B' -> Date última vez
  
  
  const WEIGHTS = { pairGlobal: 22, pairMonth: 80, pairRecentPenalty: 120, pairCooldownDays: 18, preferredMultiplier: 0 };
  const BOOST = { groupPairBonus: 20 }; // sesgo leve al grupo // empuje suave al grupo // bonus suaves
  // Límites duros por pareja
  function pairWouldExceedLimit(a,b){
    const k = canonicalPair(a,b);
    const cur = pairCount[k] || 0;
    const lim = pairLimitForKey(k);
    return cur >= lim;
  }
  function incPairCount(a,b, cell){
    const k = canonicalPair(a,b);
    const ym = cell.iso.slice(0,7);
    pairCount[k]=(pairCount[k]||0)+1;
    pairCountMonth[ym]=pairCountMonth[ym]||{};
    pairCountMonth[ym][k]=(pairCountMonth[ym][k]||0)+1;
    lastPair[k]=cell.date;
  }
  function pairPenaltyFor(name, currentAssigned, cell){
    if(!currentAssigned || currentAssigned.length===0) return 0;
    const other = currentAssigned[0];
    const k = canonicalPair(name, other);
    const ym = cell.iso.slice(0,7);
    const cntG = pairCount[k]||0;
    const cntM = (pairCountMonth[ym] && pairCountMonth[ym][k])||0;
    let p = cntG*WEIGHTS.pairGlobal + cntM*WEIGHTS.pairMonth;
    const lp = lastPair[k];
    if(lp){
      const diff = Math.round((cell.date - lp)/(1000*3600*24));
      if(diff < WEIGHTS.pairCooldownDays) p += WEIGHTS.pairRecentPenalty;
    }
    if(PREFERRED.has(k)) return 0; // no penalizar las preferidas ni Julia–Marta
    // Penalización suavizada dentro del grupo priorizado
    const [a,b] = k.split('|');
    if(PRIORITY_GROUP.has(a) && PRIORITY_GROUP.has(b)) p *= 0.8;
    return p;
  }

  function canUse(name, dt, guardiasMes){
    const L = last[name];
    if(L){
      const diff = Math.round((dt - L)/(1000*3600*24));
      if(diff <= 1) return false; // nunca dos seguidos
      const need = intervaloPorMes(guardiasMes);
      if(diff < need) return false; // respeta intervalo por grupo
    }
    // Límite mensual UNIFORME para todos según su parámetro "mes"
    const ym = ymd(dt).slice(0,7);
    monthCount[ym] = monthCount[ym] || {};
    if ((monthCount[ym][name] || 0) >= guardiasMes) return false;

    
    return true;
  }

  function penalizacionTipo(name, cell){
    let p = 0;
    if(cell.sab) p += tipoCount[name].sab * 3;
    if(cell.fest) p += tipoCount[name].fest * 4;
    if(cell.pref) p += tipoCount[name].pref * 2;
    if(cell.puente) p += tipoCount[name].puente * 2;
    if(cell.dom) p += tipoCount[name].dom * 2;
    return p;
  }

  // candidatos dinámicos (recalcula tras cada pick)
  // selección suave: softmax para evitar decisiones demasiado deterministas
  function pickBySoftmax(cands, T=0.35, topK=4){
    if(!cands.length) return null;
    const subset = cands.slice(0, Math.max(1, Math.min(topK, cands.length)));
    // convertir score a prob con softmax de coste (menor score => mayor prob)
    const xs = subset.map(c=> Math.exp(-(c.score)/Math.max(0.001,T)));
    const sum = xs.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for(let i=0;i<subset.length;i++){ r -= xs[i]; if(r<=0) return subset[i]; }
    return subset[subset.length-1];
  }

  function computeCandidates(cell, assignedNames, onlyMes2=false){
    return MEDICOS
      .filter(m=>{
        if(assignedNames.includes(m.nombre)) return false;
        if(onlyMes2 && m.mes!==2) return false;
        if(!canUse(m.nombre, cell.date, m.mes)) return false;
        if(assignedNames.length===1){
          const a = assignedNames[0];
          if(!PREFERRED.has(canonicalPair(a, m.nombre)) && pairWouldExceedLimit(a, m.nombre)) return false;
        }

        return true;
      })
      .map(m=>{
        const base = (m.mes>=8)?0 : (m.mes===4?1 : (m.mes===3?2 : (m.mes===2?3:4)));
        const pen = penalizacionTipo(m.nombre, cell);
        const pairPen = pairPenaltyFor(m.nombre, assignedNames, cell);
        let bonus = 0;
        if(assignedNames.length===1){
          const aName = assignedNames[0];
          if(PRIORITY_GROUP.has(aName) && PRIORITY_GROUP.has(m.nombre)) bonus -= BOOST.groupPairBonus;
        }
        return {m, score: base*100 + pen + pairPen + bonus};
      })
      .sort((a,b)=> a.score - b.score);
  }

  // recorrido cronológico
  months.forEach(mon=>{
    mon.days.forEach(cell=>{
      if(cell.empty) return;
      asig[cell.iso] = [];

      const elegibles = MEDICOS.filter(m=> canUse(m.nombre, cell.date, m.mes));

      // 1) Emparejamientos preferidos
      function intentarPar(a,b){
        const A = elegibles.find(x=>x.nombre===a);
        const B = elegibles.find(x=>x.nombre===b);
        // Evitar superar el tope global del periodo para esta pareja
        if(A && B){
          const k = canonicalPair(a,b);
          if(!PREFERRED.has(k) && pairWouldExceedLimit(a,b)) return false;
          asig[cell.iso].push(a,b);
          last[a]=new Date(cell.date);
          last[b]=new Date(cell.date);
          const ym = cell.iso.slice(0,7);
          monthCount[ym]=monthCount[ym]||{};
          monthCount[ym][a]=(monthCount[ym][a]||0)+1;
          monthCount[ym][b]=(monthCount[ym][b]||0)+1;
          if(cell.sab){tipoCount[a].sab++;tipoCount[b].sab++}
          if(cell.fest){tipoCount[a].fest++;tipoCount[b].fest++}
          if(cell.pref){tipoCount[a].pref++;tipoCount[b].pref++}
          if(cell.puente){tipoCount[a].puente++;tipoCount[b].puente++}
          if(cell.dom){tipoCount[a].dom++;tipoCount[b].dom++}
          incPairCount(a,b, cell);
          return true;
        }
        return false;
      }

      if(asig[cell.iso].length<2){
        if(!intentarPar('Rigo','Luceth')) intentarPar('Adela','Mica');
      }

      

      // 2) Relleno general priorizando frecuencia y equilibrio de tipos
      while(asig[cell.iso].length<2){
        const cands = computeCandidates(cell, asig[cell.iso], false);
        if(!cands.length) break;
        const pickEntry = pickBySoftmax(cands, 0.35, 4) || cands[0];
        const pick = pickEntry.m;
        // aplicar asignación
        asig[cell.iso].push(pick.nombre);
        last[pick.nombre]=new Date(cell.date);
        const ym = cell.iso.slice(0,7);
        monthCount[ym]=monthCount[ym]||{};
        monthCount[ym][pick.nombre]=(monthCount[ym][pick.nombre]||0)+1;
        if(cell.sab) tipoCount[pick.nombre].sab++;
        if(cell.fest) tipoCount[pick.nombre].fest++;
        if(cell.pref) tipoCount[pick.nombre].pref++;
        if(cell.puente) tipoCount[pick.nombre].puente++;
        if(cell.dom) tipoCount[pick.nombre].dom++;
        if(asig[cell.iso].length===2){ incPairCount(asig[cell.iso][0], asig[cell.iso][1], cell); }
      }

      // 3) Flex: sólo médicos con 2/mes (respetando tope e intervalos)
      while(asig[cell.iso].length<2){
        const flex = computeCandidates(cell, asig[cell.iso], true);
        if(!flex.length) break;
        const pickEntry = pickBySoftmax(flex, 0.35, 4) || flex[0];
        const pick = pickEntry.m;
        asig[cell.iso].push(pick.nombre);
        last[pick.nombre]=new Date(cell.date);
        const ym = cell.iso.slice(0,7);
        monthCount[ym]=monthCount[ym]||{};
        monthCount[ym][pick.nombre]=(monthCount[ym][pick.nombre]||0)+1;
        if(cell.sab) tipoCount[pick.nombre].sab++;
        if(cell.fest) tipoCount[pick.nombre].fest++;
        if(cell.pref) tipoCount[pick.nombre].pref++;
        if(cell.puente) tipoCount[pick.nombre].puente++;
        if(cell.dom) tipoCount[pick.nombre].dom++;
        if(asig[cell.iso].length===2){ incPairCount(asig[cell.iso][0], asig[cell.iso][1], cell); }
      }
    });
    });
  
  return { asig, pairCount, pairCountMonth };
}

/* =========================
   Render doctores y leyenda
   ========================= */
function renderDoctors(){
  const host = document.getElementById('doctorsList');
  host.innerHTML='';
  const medicosOrdenados = [...MEDICOS].sort((a,b)=>b.mes-a.mes);
  medicosOrdenados.forEach((m)=>{
    const div=document.createElement('div'); div.className='pill';
    const sw=document.createElement('span'); sw.className='sw'; sw.style.background=color[m.nombre];
    const txt=document.createElement('span'); txt.textContent=m.nombre;

    const input=document.createElement('input');
    input.type='number'; input.min=1; input.step=1; input.value=m.mes; input.style.width='56px';
    input.dataset.nombre = m.nombre; // mapeo robusto por nombre

    // Actualiza el modelo mientras se teclea (sin esperar blur)
    input.addEventListener('input', e=>{
      const val = Math.max(1, parseInt(e.target.value)||1);
      const doc = MEDICOS.find(d=>d.nombre===m.nombre);
      if(doc) doc.mes = val; // por nombre, no por índice
    });

    div.append(sw,txt,input); host.appendChild(div);
  });
}

/* =========================
   Render calendario + resumen
   ========================= */
function renderCalendario(asig, extras={}){
  const monthsEl=document.getElementById('months');
  monthsEl.innerHTML='';
  const meses=['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];

  const res={}; MEDICOS.forEach(m=> res[m.nombre]={tot:0,sab:0,dom:0,fest:0,pref:0,puente:0});

  months.forEach(mon=>{
    const box=document.createElement('div'); box.className='month';
    const h=document.createElement('h3'); h.textContent=`${meses[mon.month]} ${mon.year}`; box.appendChild(h);

    const monthTotals={}; MEDICOS.forEach(m=> monthTotals[m.nombre]=0);

    const grid=document.createElement('div'); grid.className='grid';
    ['L','M','X','J','V','S','D'].forEach(t=>{const hd=document.createElement('div');hd.className='cell';hd.style.fontWeight='700';hd.style.textAlign='center';hd.textContent=t;grid.appendChild(hd);});

    mon.days.forEach(cell=>{
      const c=document.createElement('div'); c.className='cell';
      if(cell.empty){ c.classList.add('empty'); grid.appendChild(c); return; }

      if(cell.fest) c.classList.add('festivo');
      else if(cell.pref) c.classList.add('pref');
      else if(cell.puente) c.classList.add('puente');
      if(cell.sab) c.classList.add('sabado');
      if(cell.dom) c.classList.add('domingo');

      const ds=document.createElement('div'); ds.className='date'; ds.textContent=cell.date.getDate(); c.appendChild(ds);

      (asig[cell.iso]||[]).forEach(n=>{
        const t=document.createElement('div'); t.className='tag'; t.style.background=color[n]; t.textContent=n;
        c.appendChild(t);
        res[n].tot++; if(cell.sab)res[n].sab++; if(cell.dom)res[n].dom++; if(cell.fest)res[n].fest++; if(cell.pref)res[n].pref++; if(cell.puente)res[n].puente++;
        monthTotals[n]++;
      });

      grid.appendChild(c);
    });

    box.appendChild(grid);

    const sum=document.createElement('div'); sum.className='month-summary';
    const totalMes = Object.values(monthTotals).reduce((a,b)=>a+b,0);
    const h4=document.createElement('h4'); h4.textContent=`Resumen del mes — Total guardias: ${totalMes}`; sum.appendChild(h4);

    const tabla=document.createElement('table');
    const thead=document.createElement('thead');
    thead.innerHTML='<tr><th style="text-align:left">Médico</th><th>Total (mes)</th></tr>';
    tabla.appendChild(thead);
    const tbody=document.createElement('tbody');

    const filas = Object.keys(monthTotals)
      .map(n=>({n, c:monthTotals[n]}))
      .sort((a,b)=> b.c - a.c || a.n.localeCompare(b.n));

    filas.forEach(({n,c})=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`<td style="background:${color[n]}">${n}</td><td>${c}</td>`;
      tbody.appendChild(tr);
    });

    tabla.appendChild(tbody);
    sum.appendChild(tabla);
    box.appendChild(sum);

    // Top parejas del mes (hasta 5)
    const ym = `${mon.year}-${pad(mon.month+1)}`;
    const pm = (extras.pairCountMonth && extras.pairCountMonth[ym]) || {};
    const monthPairs = Object.entries(pm).sort((a,b)=>b[1]-a[1]).slice(0,5);
    if(monthPairs.length){
      const sumPairs = document.createElement('div'); sumPairs.className='month-summary';
      const hPairs = document.createElement('h4'); hPairs.textContent='Top parejas del mes'; sumPairs.appendChild(hPairs);
      const t2=document.createElement('table'); t2.innerHTML='<thead><tr><th>Pareja</th><th>Veces</th></tr></thead>';
      const tb2=document.createElement('tbody');
      monthPairs.forEach(([k,c])=>{ const [a,b]=k.split('|'); const tr=document.createElement('tr');
      const lim = pairLimitForKey(k);
      if(c>lim){ tr.style.background='#ffecec'; tr.style.border='1px solid #e74c3c'; }
      tr.innerHTML=`<td>${a} — ${b}</td><td>${c}</td>`; tb2.appendChild(tr); });
      t2.appendChild(tb2); sumPairs.appendChild(t2); box.appendChild(sumPairs);
    }

    monthsEl.appendChild(box);
  });

  const tb=document.getElementById('resumenBody'); tb.innerHTML='';
  const medicosOrdenados = [...MEDICOS].sort((a,b)=>b.mes-a.mes);
  medicosOrdenados.forEach(m=>{
    const r=res[m.nombre];
    const tr=document.createElement('tr');
    tr.innerHTML=`<td style=\"background:${color[m.nombre]}\">${m.nombre}</td>
                  <td>${r.tot}</td><td>${r.sab}</td><td>${r.dom}</td><td>${r.fest}</td><td>${r.pref}</td><td>${r.puente}</td>`;
    tb.appendChild(tr);
  });

  // Resumen de parejas (global del periodo)
  const pairHost = document.getElementById('pairSummary');
  if(pairHost){
    const entries = Object.entries(extras.pairCount || {}).sort((a,b)=> b[1]-a[1]);
    const table=document.createElement('table');
    table.innerHTML='<thead><tr><th>Pareja</th><th>Veces</th></tr></thead>';
    const tbody=document.createElement('tbody');
    entries.forEach(([k,c])=>{ const [a,b]=k.split('|'); const tr=document.createElement('tr');
    const lim = pairLimitForKey(k);
    if(c>lim){ tr.style.background='#ffecec'; tr.style.border='1px solid #e74c3c'; }
    tr.innerHTML=`<td>${a} — ${b}</td><td>${c}</td>`; tbody.appendChild(tr); });
    table.appendChild(tbody);
    pairHost.innerHTML='<h4 style=\"margin:10px 0 6px\">Parejas más repetidas (periodo)</h4>';
    pairHost.appendChild(table);
  }
}

/* ================
   Start + Eventos
   ================ */
buildMonths();
renderDoctors();

document.getElementById('btnGenerar').addEventListener('click', ()=>{
  // 1) Leer SIEMPRE los inputs por nombre (el listado está ordenado y no coincide con índices de MEDICOS)
  const inputs = document.querySelectorAll('#doctorsList input[type="number"]');
  inputs.forEach(input => {
    const nombre = input.dataset.nombre;
    const val = Math.max(1, parseInt(input.value)||1);
    const doc = MEDICOS.find(m=>m.nombre===nombre);
    if(doc) doc.mes = val;
  });

  // 2) Recalcular
  buildMonths();
  const gen = generarAsignacion();
  renderCalendario(gen.asig, { pairCount: gen.pairCount, pairCountMonth: gen.pairCountMonth });

  // 3) (Opcional) re-render de la lista si quieres que se reordene por nuevo "mes"
  // renderDoctors();
});

// Autogenerar en carga para ver algo
setTimeout(()=>document.getElementById('btnGenerar').click());
</script>
</body>
</html>
